//! Generated file, do not edit by hand, see `xtask/src/codegen`

#![allow(bad_style, missing_docs, unreachable_pub)]
#[doc = r" The kind of syntax node, e.g. `IDENT`, `USE_KW`, or `STRUCT`."]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
#[repr(u16)]
pub enum SyntaxKind {
    #[doc(hidden)]
    TOMBSTONE,
    #[doc(hidden)]
    EOF,
    SEMICOLON,
    COMMA,
    L_PAREN,
    R_PAREN,
    L_CURLY,
    R_CURLY,
    L_BRACK,
    R_BRACK,
    L_ANGLE,
    R_ANGLE,
    QUESTION,
    AMP,
    PLUS,
    STAR,
    SLASH,
    PERCENT,
    UNDERSCORE,
    DOT,
    EQ,
    EQ2,
    FAT_ARROW,
    BANG,
    NEQ,
    MINUS,
    LTEQ,
    GTEQ,
    AMP2,
    PIPE2,
    COLON,
    PIPE,
    AS_KW,
    ADDS_KW,
    AFTER_KW,
    ASSERT_KW,
    AWAIT_KW,
    BUILTIN_KW,
    CASE_KW,
    CATCH_KW,
    CLASS_KW,
    CORE_KW,
    DATA_KW,
    DEF_KW,
    DELTA_KW,
    DIE_KW,
    DURATION_KW,
    ELSE_KW,
    EXCEPTION_KW,
    EXPORT_KW,
    EXTENDS_KW,
    FEATURES_KW,
    FINALLY_KW,
    FOREACH_KW,
    FROM_KW,
    GET_KW,
    HAS_FIELD_KW,
    HAS_INTERFACE_KW,
    HAS_METHOD_KW,
    IF_KW,
    IMPLEMENTS_KW,
    IMPORT_KW,
    IN_KW,
    INTERFACE_KW,
    LET_KW,
    LOCAL_KW,
    MODIFIES_KW,
    MODULE_KW,
    MOVECOGTO_KW,
    NEW_KW,
    NULL_KW,
    ORIGINAL_KW,
    PRODUCT_KW,
    PRODUCTLINE_KW,
    RECOVER_KW,
    REMOVES_KW,
    RETURN_KW,
    SWITCH_KW,
    SKIP_KW,
    SUSPEND_KW,
    THEN_KW,
    THIS_KW,
    THROW_KW,
    TRAIT_KW,
    TRY_KW,
    TYPE_KW,
    USES_KW,
    WHEN_KW,
    WHILE_KW,
    INT_NUMBER,
    FLOAT_NUMBER,
    STRING,
    ERROR,
    LOW_IDENT,
    CAP_IDENT,
    WHITESPACE,
    COMMENT,
    VAR_NAME,
    TYPE_NAME,
    PATH,
    TYPE_PATH,
    PARAM_LIST,
    PARAM,
    TYPE,
    ANNOTATION,
    ANNOTATIONS,
    FN_EXPR,
    PARTIAL_FN_EXPR,
    VARIADIC_FN_EXPR,
    CONSTRUCTOR_EXPR,
    UNARY_EXPR,
    BINARY_EXPR,
    NAME_EXPR,
    LITERAL,
    THIS_EXPR,
    NULL_EXPR,
    IMPLEMENTS_EXPR,
    AS_EXPR,
    WHEN_EXPR,
    CASE_EXPR,
    LET_EXPR,
    PAREN_EXPR,
    PURE_EXPR_LIST,
    FN_LIST,
    FN_LIST_PARAM,
    ANON_FN,
    CASE_EXPR_BRANCH,
    LET_DEFS,
    LET_DEF,
    EFF_EXPR,
    GET_EXPR,
    NEW_EXPR,
    ASYNC_CALL_EXPR,
    SYNC_CALL_EXPR,
    ORIGINAL_CALL_EXPR,
    VAR_DECL_STMT,
    ASSIGN_STMT,
    SKIP_STMT,
    RETURN_STMT,
    ASSERT_STMT,
    BLOCK,
    IF_STMT,
    SWITCH_STMT,
    WHILE_STMT,
    FOREACH_STMT,
    TRY_CATCH_FINALLY_STMT,
    AWAIT_STMT,
    SUSPEND_STMT,
    DURATION_STMT,
    THROW_STMT,
    DIE_STMT,
    MOVE_COG_TO_STMT,
    EXPR_STMT,
    CLAIM_GUARD,
    DURATION_GUARD,
    EXPR_GUARD,
    AND_GUARD,
    CASE_STMT_BRANCH,
    WILD_CARD_PATTERN,
    INT_PATTERN,
    STRING_PATTERN,
    VAR_PATTERN,
    CONSTRUCTOR_PATTERN,
    DATA_TYPE_DECL,
    GENERIC_ARG_LIST,
    DATA_CONSTRUCTOR_LIST,
    DATA_CONSTRUCTOR,
    DATA_CONSTRUCTOR_ARG_LIST,
    DATA_CONSTRUCTOR_ARG,
    TYPE_SYN,
    EXCEPTION_DECL,
    FUNCTION_DECL,
    PAR_FUNCTION_DECL,
    FUNCTION_NAME_LIST,
    INTERFACE_DECL,
    INTERFACE_ITEM,
    EXTENDS_LIST,
    METHOD_SIG,
    METHOD_DECL,
    CLASS_DECL,
    IMPLEMENTS_LIST,
    FIELD_DECL,
    RECOVER_BLOCK,
    MODULE,
    IMPORT_LIST,
    EXPORT_LIST,
    STAR_IMPORT,
    FROM_IMPORT,
    UNQUALIFIED_IMPORT,
    STAR_EXPORT,
    PARTIAL_EXPORT,
    TRAIT_DECL,
    TRAIT_EXPR,
    BASIC_TRAIT_EXPR,
    TRAIT_METHOD_SET,
    TRAIT_METHOD,
    TRAIT_NAME,
    TRAIT_REMOVE_SIG,
    TRAIT_REMOVE_SET,
    TRAIT_ADD,
    TRAIT_MODIFIES,
    TRAIT_USE,
    #[doc(hidden)]
    __LAST,
}
use self::SyntaxKind::*;
impl SyntaxKind {
    pub fn is_keyword(self) -> bool {
        match self {
            AS_KW | ADDS_KW | AFTER_KW | ASSERT_KW | AWAIT_KW | BUILTIN_KW | CASE_KW | CATCH_KW
            | CLASS_KW | CORE_KW | DATA_KW | DEF_KW | DELTA_KW | DIE_KW | DURATION_KW | ELSE_KW
            | EXCEPTION_KW | EXPORT_KW | EXTENDS_KW | FEATURES_KW | FINALLY_KW | FOREACH_KW
            | FROM_KW | GET_KW | HAS_FIELD_KW | HAS_INTERFACE_KW | HAS_METHOD_KW | IF_KW
            | IMPLEMENTS_KW | IMPORT_KW | IN_KW | INTERFACE_KW | LET_KW | LOCAL_KW
            | MODIFIES_KW | MODULE_KW | MOVECOGTO_KW | NEW_KW | NULL_KW | ORIGINAL_KW
            | PRODUCT_KW | PRODUCTLINE_KW | RECOVER_KW | REMOVES_KW | RETURN_KW | SWITCH_KW
            | SKIP_KW | SUSPEND_KW | THEN_KW | THIS_KW | THROW_KW | TRAIT_KW | TRY_KW | TYPE_KW
            | USES_KW | WHEN_KW | WHILE_KW => true,
            _ => false,
        }
    }
    pub fn is_punct(self) -> bool {
        match self {
            SEMICOLON | COMMA | L_PAREN | R_PAREN | L_CURLY | R_CURLY | L_BRACK | R_BRACK
            | L_ANGLE | R_ANGLE | QUESTION | AMP | PLUS | STAR | SLASH | PERCENT | UNDERSCORE
            | DOT | EQ | EQ2 | FAT_ARROW | BANG | NEQ | MINUS | LTEQ | GTEQ | AMP2 | PIPE2
            | COLON | PIPE => true,
            _ => false,
        }
    }
    pub fn is_literal(self) -> bool {
        match self {
            INT_NUMBER | FLOAT_NUMBER | STRING => true,
            _ => false,
        }
    }
    pub fn from_keyword(ident: &str) -> Option<SyntaxKind> {
        let kw = match ident {
            "as" => AS_KW,
            "adds" => ADDS_KW,
            "after" => AFTER_KW,
            "assert" => ASSERT_KW,
            "await" => AWAIT_KW,
            "builtin" => BUILTIN_KW,
            "case" => CASE_KW,
            "catch" => CATCH_KW,
            "class" => CLASS_KW,
            "core" => CORE_KW,
            "data" => DATA_KW,
            "def" => DEF_KW,
            "delta" => DELTA_KW,
            "die" => DIE_KW,
            "duration" => DURATION_KW,
            "else" => ELSE_KW,
            "exception" => EXCEPTION_KW,
            "export" => EXPORT_KW,
            "extends" => EXTENDS_KW,
            "features" => FEATURES_KW,
            "finally" => FINALLY_KW,
            "foreach" => FOREACH_KW,
            "from" => FROM_KW,
            "get" => GET_KW,
            "hasField" => HAS_FIELD_KW,
            "hasInterface" => HAS_INTERFACE_KW,
            "hasMethod" => HAS_METHOD_KW,
            "if" => IF_KW,
            "implements" => IMPLEMENTS_KW,
            "import" => IMPORT_KW,
            "in" => IN_KW,
            "interface" => INTERFACE_KW,
            "let" => LET_KW,
            "local" => LOCAL_KW,
            "modifies" => MODIFIES_KW,
            "module" => MODULE_KW,
            "movecogto" => MOVECOGTO_KW,
            "new" => NEW_KW,
            "null" => NULL_KW,
            "original" => ORIGINAL_KW,
            "product" => PRODUCT_KW,
            "productline" => PRODUCTLINE_KW,
            "recover" => RECOVER_KW,
            "removes" => REMOVES_KW,
            "return" => RETURN_KW,
            "switch" => SWITCH_KW,
            "skip" => SKIP_KW,
            "suspend" => SUSPEND_KW,
            "then" => THEN_KW,
            "this" => THIS_KW,
            "throw" => THROW_KW,
            "trait" => TRAIT_KW,
            "try" => TRY_KW,
            "type" => TYPE_KW,
            "uses" => USES_KW,
            "when" => WHEN_KW,
            "while" => WHILE_KW,
            _ => return None,
        };
        Some(kw)
    }
    pub fn from_char(c: char) -> Option<SyntaxKind> {
        let tok = match c {
            ';' => SEMICOLON,
            ',' => COMMA,
            '(' => L_PAREN,
            ')' => R_PAREN,
            '{' => L_CURLY,
            '}' => R_CURLY,
            '[' => L_BRACK,
            ']' => R_BRACK,
            '<' => L_ANGLE,
            '>' => R_ANGLE,
            '?' => QUESTION,
            '&' => AMP,
            '+' => PLUS,
            '*' => STAR,
            '/' => SLASH,
            '%' => PERCENT,
            '_' => UNDERSCORE,
            '.' => DOT,
            '=' => EQ,
            '!' => BANG,
            '-' => MINUS,
            ':' => COLON,
            '|' => PIPE,
            _ => return None,
        };
        Some(tok)
    }
}
#[macro_export]
macro_rules ! T { [;] => { $ crate :: SyntaxKind :: SEMICOLON } ; [,] => { $ crate :: SyntaxKind :: COMMA } ; ['('] => { $ crate :: SyntaxKind :: L_PAREN } ; [')'] => { $ crate :: SyntaxKind :: R_PAREN } ; ['{'] => { $ crate :: SyntaxKind :: L_CURLY } ; ['}'] => { $ crate :: SyntaxKind :: R_CURLY } ; ['['] => { $ crate :: SyntaxKind :: L_BRACK } ; [']'] => { $ crate :: SyntaxKind :: R_BRACK } ; [<] => { $ crate :: SyntaxKind :: L_ANGLE } ; [>] => { $ crate :: SyntaxKind :: R_ANGLE } ; [?] => { $ crate :: SyntaxKind :: QUESTION } ; [&] => { $ crate :: SyntaxKind :: AMP } ; [+] => { $ crate :: SyntaxKind :: PLUS } ; [*] => { $ crate :: SyntaxKind :: STAR } ; [/] => { $ crate :: SyntaxKind :: SLASH } ; [%] => { $ crate :: SyntaxKind :: PERCENT } ; [_] => { $ crate :: SyntaxKind :: UNDERSCORE } ; [.] => { $ crate :: SyntaxKind :: DOT } ; [=] => { $ crate :: SyntaxKind :: EQ } ; [==] => { $ crate :: SyntaxKind :: EQ2 } ; [=>] => { $ crate :: SyntaxKind :: FAT_ARROW } ; [!] => { $ crate :: SyntaxKind :: BANG } ; [!=] => { $ crate :: SyntaxKind :: NEQ } ; [-] => { $ crate :: SyntaxKind :: MINUS } ; [<=] => { $ crate :: SyntaxKind :: LTEQ } ; [>=] => { $ crate :: SyntaxKind :: GTEQ } ; [&&] => { $ crate :: SyntaxKind :: AMP2 } ; [||] => { $ crate :: SyntaxKind :: PIPE2 } ; [:] => { $ crate :: SyntaxKind :: COLON } ; [|] => { $ crate :: SyntaxKind :: PIPE } ; [as] => { $ crate :: SyntaxKind :: AS_KW } ; [adds] => { $ crate :: SyntaxKind :: ADDS_KW } ; [after] => { $ crate :: SyntaxKind :: AFTER_KW } ; [assert] => { $ crate :: SyntaxKind :: ASSERT_KW } ; [await] => { $ crate :: SyntaxKind :: AWAIT_KW } ; [builtin] => { $ crate :: SyntaxKind :: BUILTIN_KW } ; [case] => { $ crate :: SyntaxKind :: CASE_KW } ; [catch] => { $ crate :: SyntaxKind :: CATCH_KW } ; [class] => { $ crate :: SyntaxKind :: CLASS_KW } ; [core] => { $ crate :: SyntaxKind :: CORE_KW } ; [data] => { $ crate :: SyntaxKind :: DATA_KW } ; [def] => { $ crate :: SyntaxKind :: DEF_KW } ; [delta] => { $ crate :: SyntaxKind :: DELTA_KW } ; [die] => { $ crate :: SyntaxKind :: DIE_KW } ; [duration] => { $ crate :: SyntaxKind :: DURATION_KW } ; [else] => { $ crate :: SyntaxKind :: ELSE_KW } ; [exception] => { $ crate :: SyntaxKind :: EXCEPTION_KW } ; [export] => { $ crate :: SyntaxKind :: EXPORT_KW } ; [extends] => { $ crate :: SyntaxKind :: EXTENDS_KW } ; [features] => { $ crate :: SyntaxKind :: FEATURES_KW } ; [finally] => { $ crate :: SyntaxKind :: FINALLY_KW } ; [foreach] => { $ crate :: SyntaxKind :: FOREACH_KW } ; [from] => { $ crate :: SyntaxKind :: FROM_KW } ; [get] => { $ crate :: SyntaxKind :: GET_KW } ; [hasField] => { $ crate :: SyntaxKind :: HAS_FIELD_KW } ; [hasInterface] => { $ crate :: SyntaxKind :: HAS_INTERFACE_KW } ; [hasMethod] => { $ crate :: SyntaxKind :: HAS_METHOD_KW } ; [if] => { $ crate :: SyntaxKind :: IF_KW } ; [implements] => { $ crate :: SyntaxKind :: IMPLEMENTS_KW } ; [import] => { $ crate :: SyntaxKind :: IMPORT_KW } ; [in] => { $ crate :: SyntaxKind :: IN_KW } ; [interface] => { $ crate :: SyntaxKind :: INTERFACE_KW } ; [let] => { $ crate :: SyntaxKind :: LET_KW } ; [local] => { $ crate :: SyntaxKind :: LOCAL_KW } ; [modifies] => { $ crate :: SyntaxKind :: MODIFIES_KW } ; [module] => { $ crate :: SyntaxKind :: MODULE_KW } ; [movecogto] => { $ crate :: SyntaxKind :: MOVECOGTO_KW } ; [new] => { $ crate :: SyntaxKind :: NEW_KW } ; [null] => { $ crate :: SyntaxKind :: NULL_KW } ; [original] => { $ crate :: SyntaxKind :: ORIGINAL_KW } ; [product] => { $ crate :: SyntaxKind :: PRODUCT_KW } ; [productline] => { $ crate :: SyntaxKind :: PRODUCTLINE_KW } ; [recover] => { $ crate :: SyntaxKind :: RECOVER_KW } ; [removes] => { $ crate :: SyntaxKind :: REMOVES_KW } ; [return] => { $ crate :: SyntaxKind :: RETURN_KW } ; [switch] => { $ crate :: SyntaxKind :: SWITCH_KW } ; [skip] => { $ crate :: SyntaxKind :: SKIP_KW } ; [suspend] => { $ crate :: SyntaxKind :: SUSPEND_KW } ; [then] => { $ crate :: SyntaxKind :: THEN_KW } ; [this] => { $ crate :: SyntaxKind :: THIS_KW } ; [throw] => { $ crate :: SyntaxKind :: THROW_KW } ; [trait] => { $ crate :: SyntaxKind :: TRAIT_KW } ; [try] => { $ crate :: SyntaxKind :: TRY_KW } ; [type] => { $ crate :: SyntaxKind :: TYPE_KW } ; [uses] => { $ crate :: SyntaxKind :: USES_KW } ; [when] => { $ crate :: SyntaxKind :: WHEN_KW } ; [while] => { $ crate :: SyntaxKind :: WHILE_KW } ; [lower_ident] => { $ crate :: SyntaxKind :: LOW_IDENT } ; [cap_ident] => { $ crate :: SyntaxKind :: CAP_IDENT } ; }
